import { TypeNode } from '../type-node/type-node.abstract';
import { Display } from '../style/style.enum';
import { humpToMiddleLine } from './type-element.function';
export class TypeElement extends TypeNode {
    propObj;
    childNodes;
    events;
    constructor(nodeName) {
        super(nodeName);
        this.propObj = {
            attrObj: {},
            styleObj: {}
        };
        this.attributes = [];
        this.childNodes = [];
        this.events = [];
    }
    get length() {
        return this.childNodes.length;
    }
    get index() {
        return this.parent ? this.parent.findChildIndex(this) : -1;
    }
    get attrObj() {
        return this.propObj.attrObj;
    }
    get styleObj() {
        return this.propObj.styleObj;
    }
    get firstChild() {
        return this.childNodes[0];
    }
    get lastChild() {
        return this.childNodes[this.length - 1];
    }
    get id() {
        return this.attrObj.id;
    }
    setAttrId(id) {
        this.addAttrId(id);
        this.renderAttrId(id);
    }
    addAttrId(id) {
        this.propObj.attrObj.id = id;
    }
    renderAttrId(id) {
        this.dom.setAttribute('id', id);
    }
    setPropObj(propObj) {
        if (this.propObj) {
            for (const key in this.propObj.attrObj) {
                this.removeAttribute(key);
            }
            this.dom.removeAttribute('style');
        }
        this.propObj = propObj;
        this.setAttrObj(propObj.attrObj);
        this.setStyleObj(propObj.styleObj);
    }
    setStyleObj(styles) {
        for (const key in styles) {
            if (Object.hasOwnProperty.call(styles, key)) {
                const value = styles[key];
                this.setStyle(key, value);
            }
        }
        return this;
    }
    addStyleObj(styles) {
        for (const key in styles) {
            if (Object.hasOwnProperty.call(styles, key)) {
                const value = styles[key];
                this.addStyle(key, value);
            }
        }
    }
    renderStyleObj(styles) {
        for (const key in styles) {
            if (Object.hasOwnProperty.call(styles, key)) {
                const value = styles[key];
                this.renderStyle(key, value);
            }
        }
    }
    setStyle(key, value) {
        this.addStyle(key, value);
        this.renderStyle(key, value);
    }
    addStyle(key, value) {
        this.propObj.styleObj[key] = value;
    }
    renderStyle(key, value) {
        this.dom.style[key] = String(value);
    }
    removeStyle(key) {
        if (this.propObj.styleObj[key]) {
            delete this.propObj.styleObj[key];
        }
        this.dom.style.removeProperty(humpToMiddleLine(key));
        return this;
    }
    show(mode = 'block') {
        this.setStyle('display', Display[mode]);
    }
    hide() {
        this.setStyle('display', 'none');
    }
    setAttrObj(attrObj) {
        for (const key in attrObj) {
            if (Object.hasOwnProperty.call(attrObj, key)) {
                const value = attrObj[key];
                this.setAttribute(key, value);
            }
        }
        return this;
    }
    addAttrObj(attrObj) {
        for (const key in attrObj) {
            if (Object.hasOwnProperty.call(attrObj, key)) {
                const value = attrObj[key];
                this.addAttribute(key, value);
            }
        }
        return this;
    }
    renderAttrObj(attrObj) {
        for (const key in attrObj) {
            if (Object.hasOwnProperty.call(attrObj, key)) {
                const value = attrObj[key];
                this.renderAttribute(key, value);
            }
        }
        return this;
    }
    setAttribute(key, value) {
        this.addAttribute(key, value);
        this.renderAttribute(key, value);
        return this;
    }
    addAttribute(key, value) {
        this.propObj.attrObj[key] = value;
    }
    renderAttribute(key, value) {
        if (value === true) {
            this.dom.setAttribute(key, '');
        }
        else if (value === false) {
            this.dom.removeAttribute(key);
        }
        else {
            this.dom.setAttribute(key, String(value));
        }
    }
    setAttrName(value) {
        this.addAttrName(value);
        this.renderAttrName(value);
        return this;
    }
    addAttrName(value) {
        this.propObj.attrObj.name = value;
    }
    renderAttrName(value) {
        this.dom.setAttribute('name', value);
    }
    removeAttribute(key) {
        if (this.propObj.attrObj[key]) {
            delete this.propObj.attrObj[key];
        }
        this.dom.removeAttribute(key);
        return this;
    }
    addClassName(className) {
        if (this.propObj.attrObj?.class?.indexOf(className) === -1) {
            this.propObj.attrObj.class += ' ' + className;
        }
        this.dom.classList.add(className);
        return this;
    }
    removeClassName(className) {
        String(this.propObj.attrObj.class).replace(className, '');
        this.dom.classList.remove(className);
        return this;
    }
    appendChild(newChild) {
        newChild.setParent(this);
        this.childNodes.push(newChild);
        this.renderChild(newChild);
    }
    unshiftChild(newChild) {
        this.childNodes.unshift(newChild);
    }
    addChild(newChild) {
        this.childNodes.push(newChild);
    }
    addChildren(...newChildren) {
        this.childNodes.push(...newChildren);
    }
    renderChild(newChild) {
        newChild.render();
        this.dom.appendChild(newChild.dom);
    }
    insertChild(newChild, index) {
        if (this.childNodes.length > index + 1) {
            this.dom.insertBefore(newChild.dom, this.dom.childNodes[index]);
        }
        else {
            this.renderChild(newChild);
        }
        return newChild.dom;
    }
    removeChildAtIndex(index, length = 1) {
        this.removeChildDom(index, length);
        this.childNodes.splice(index, length);
    }
    removeChildDom(index, length = 1) {
        for (let i = 0; i < length; i++) {
            this.dom.removeChild(this.childNodes[index + i].dom);
        }
    }
    removeFromParent() {
        if (this.parent) {
            this.parent.childNodes.splice(this.index, 1);
        }
        else {
            console.error('this.parent is null . ');
        }
    }
    clearChildDom() {
        let first = this.dom.firstElementChild;
        while (first) {
            first.remove();
            first = this.dom.firstElementChild;
        }
    }
    clearChildNodes() {
        this.childNodes = [];
    }
    removeDom() {
        if (this.dom) {
            this.dom.remove();
        }
        else {
            console.error('this.dom has been removed . ');
        }
    }
    findChildAtIndex(index) {
        return this.childNodes[index] || null;
    }
    findChildIndex(child) {
        return this.childNodes.findIndex(item => item === child);
    }
    removeEvents() {
        this.events.forEach(event => {
            event.unsubscribe();
        });
        this.events = [];
    }
    clearEvents() {
        this.events.map(item => item.unsubscribe());
    }
    get boundBox() {
        const { left, top, width, height } = this.dom.getBoundingClientRect();
        return {
            left,
            top,
            width,
            height
        };
    }
    setConfig(config) {
        this.setAttrObj(config);
    }
    createInstance(literal) {
        this.setPropObj(literal.propObj);
        const length = literal.childNodes.length;
        if (length < this.length) {
            for (let i = 0; i < this.length; i++) {
                if (i > length - 1) {
                    this.childNodes[i].dom.remove();
                }
            }
            this.childNodes.length = length;
        }
    }
    createItem(parent, node) {
        const item = new node.TypeClass();
        console.log('item is ', item);
        item.setParent(parent);
        if (node.config && item.setConfig) {
            item.setConfig(node.config);
        }
        parent.addChild(item);
        if (node.propObj) {
            if (item instanceof TypeElement) {
                item.addStyleObj(node.propObj.styleObj);
                item.addAttrObj(node.propObj.attrObj);
            }
            else {
                throw Error('TextNode propObj is undefined . ');
            }
        }
        if (node.nodeName) {
            item.nodeName = node.nodeName;
            item.dom = document.createElement(this.nodeName);
        }
        if (node.nodeValue !== undefined) {
            if (item.nodeValue !== undefined) {
                item.nodeValue = node.nodeValue;
                return item;
            }
            else {
                throw Error('TypeClass is not TextNode, but nodeValue exist. ');
            }
        }
        if (node.childNodes) {
            if (item.childNodes !== undefined) {
                item.childNodes = item.createItems(item, node.childNodes);
            }
            else {
                throw Error('TypeClass is TextNode, but has childNodes . ');
            }
        }
        return item;
    }
    render() {
        this.setStyleObj(this.styleObj);
        this.setAttrObj(this.attrObj);
        this.clearChildDom();
        for (const child of this.childNodes) {
            this.renderChild(child);
        }
    }
}
