const Entities = {
    0x3c: '&lt;',
    0x3e: '&gt;',
    0x26: '&amp;',
    0x22: '&quot;',
    0x27: '&apos;',
};
function encodeToDomString(str) {
    const buffer = [];
    let start = 0;
    for (let i = 0, ii = str.length; i < ii; i++) {
        const char = str.codePointAt(i);
        if (0x20 <= char && char <= 0x7e) {
            const entity = Entities[char];
            if (entity) {
                if (start < i) {
                    buffer.push(str.substring(start, i));
                }
                buffer.push(entity);
                start = i + 1;
            }
        }
        else {
            if (start < i) {
                buffer.push(str.substring(start, i));
            }
            buffer.push(`&#x${char.toString(16).toUpperCase()};`);
            if (char > 0xd7ff && (char < 0xe000 || char > 0xfffd)) {
                i++;
            }
            start = i + 1;
        }
    }
    if (buffer.length === 0) {
        return str;
    }
    if (start < str.length) {
        buffer.push(str.substring(start, str.length));
    }
    return buffer.join('');
}
export class TypeNode {
    propObj;
    nodeName;
    nodeValue;
    childNodes;
    attributes;
    events;
    constructor(nodeName, nodeValue) {
        this.nodeName = nodeName;
        if (nodeValue !== undefined) {
            this.nodeValue = nodeValue;
        }
    }
    get firstChild() {
        return this.childNodes && this.childNodes[0];
    }
    get nextSibling() {
        const childNodes = this.parent?.childNodes;
        if (!childNodes) {
            return undefined;
        }
        const index = childNodes.indexOf(this);
        if (index === -1) {
            return undefined;
        }
        return childNodes[index + 1];
    }
    get textContent() {
        if (!this.childNodes) {
            return this.nodeValue || '';
        }
        return this.childNodes
            .map(function (child) {
            return child.textContent;
        })
            .join('');
    }
    get children() {
        return this.childNodes || [];
    }
    setParent(parent) {
        this.parent = parent;
    }
    createItems(parent, nodes) {
        const items = [];
        for (const node of nodes) {
            if (node.TypeClass === undefined) {
                console.error('node.TypeClass is undefined . ');
                continue;
            }
            const item = this.createItem(parent, node);
            if (item) {
                items.push(item);
            }
        }
        return items;
    }
    hasChildNodes() {
        return this.childNodes ? this.childNodes.length > 0 : false;
    }
    searchNode(paths, pos) {
        if (pos >= paths.length) {
            return this;
        }
        const component = paths[pos];
        const stack = [];
        let node = this;
        while (true) {
            if (component.name === node.nodeName) {
                if (component.pos === 0) {
                    const res = node.searchNode(paths, pos + 1);
                    if (res !== null) {
                        return res;
                    }
                }
                else if (stack.length === 0) {
                    return null;
                }
                else {
                    const [parent] = stack.pop();
                    let siblingPos = 0;
                    for (const child of parent.childNodes) {
                        if (component.name === child.nodeName) {
                            if (siblingPos === component.pos) {
                                return child.searchNode(paths, pos + 1);
                            }
                            siblingPos++;
                        }
                    }
                    return node.searchNode(paths, pos + 1);
                }
            }
            if (node.childNodes && node.childNodes.length !== 0) {
                stack.push([node, 0]);
                node = node.childNodes[0];
            }
            else if (stack.length === 0) {
                return null;
            }
            else {
                while (stack.length !== 0) {
                    const [parent, currentPos] = stack.pop();
                    const newPos = currentPos + 1;
                    if (newPos < parent.childNodes.length) {
                        stack.push([parent, newPos]);
                        node = parent.childNodes[newPos];
                        break;
                    }
                }
                if (stack.length === 0) {
                    return null;
                }
            }
        }
    }
    dump(buffer) {
        if (this.nodeName === '#text') {
            buffer.push(encodeToDomString(this.nodeValue?.toString() || ''));
            return;
        }
        buffer.push(`<${this.nodeName}`);
        if (this.attributes) {
            for (const attribute of this.attributes) {
                buffer.push(` ${attribute.name}="${encodeToDomString(attribute.value.toString())}"`);
            }
        }
        if (this.hasChildNodes()) {
            buffer.push('>');
            if (this.childNodes) {
                for (const child of this.childNodes) {
                    child.dump(buffer);
                }
            }
            buffer.push(`</${this.nodeName}>`);
        }
        else if (this.nodeValue) {
            buffer.push(`>${encodeToDomString(this.nodeValue.toString())}</${this.nodeName}>`);
        }
        else {
            buffer.push('/>');
        }
    }
    toJSON() {
        return {
            nodeName: this.nodeName,
            className: this.className,
            attributes: this.attributes,
            childNodes: this.children.map(child => {
                if (child.nodeName === '#text') {
                    return {
                        className: 'TextNode',
                        nodeName: '#text',
                        nodeValue: child.nodeValue,
                    };
                }
                else {
                    return child.toJSON();
                }
            })
        };
    }
}
